# 环境变量管理方式对比分析

## 概述

在前端项目中，有两种主要的环境变量管理方式：**编译时变量**和**运行时变量**。本文档将详细对比这两种方式的区别、优缺点和使用场景。

## 1. 编译时变量 (.env 文件方式)

### 定义
编译时变量是在构建阶段就确定的变量，通过 `.env` 文件定义，在打包时被静态替换到代码中。

### 实现方式

#### 文件结构
```
project/
├── .env                    # 基础环境变量
├── .env.development        # 开发环境
├── .env.staging           # 测试环境
├── .env.production        # 生产环境
└── src/
    └── utils/request.ts   # 使用环境变量
```

#### 配置示例
```bash
# .env.development
NODE_ENV=development
VITE_APP_BASE_URL=http://localhost:8081
VITE_APP_UPLOAD_API=http://localhost:8081/upload
VITE_APP_CDN=http://www.aliyun.com
VITE_APP_MOCK=true
VITE_APP_MOCK_API=http://www.xxx.com
```

#### 使用方式
```typescript
// src/utils/request.ts
const instance = axios.create({
  baseURL: import.meta.env.VITE_APP_BASE_URL,  // 编译时替换
  timeout: 8000,
});

// 在组件中使用
const apiUrl = import.meta.env.VITE_APP_BASE_URL;
const isMock = import.meta.env.VITE_APP_MOCK === 'true';
```

### 优点
1. **安全性高**：敏感信息在构建时处理，不会暴露在运行时
2. **性能好**：变量在编译时就确定，运行时无需计算
3. **类型安全**：可以通过 TypeScript 定义类型
4. **工具支持好**：IDE 有良好的智能提示
5. **标准化**：符合现代前端工程化规范

### 缺点
1. **部署不灵活**：每个环境需要单独构建
2. **运维复杂**：无法在不重新构建的情况下修改配置
3. **CI/CD 复杂**：需要为每个环境配置不同的构建流程
4. **调试困难**：生产环境问题需要重新构建才能调试

### 构建流程
```bash
# 开发环境
npm run dev          # 使用 .env.development

# 测试环境构建
npm run build:stg    # 使用 .env.staging

# 生产环境构建
npm run build        # 使用 .env.production
```

## 2. 运行时变量 (config/index.ts 方式)

### 定义
运行时变量是在应用运行时根据当前环境动态确定的变量，通过 JavaScript 代码逻辑判断环境。

### 实现方式

#### 文件结构
```
project/
└── src/
    ├── config/
    │   └── index.ts       # 运行时配置
    └── utils/
        └── request.ts     # 使用配置
```

#### 配置示例
```typescript
// src/config/index.ts
type ENV = 'dev' | 'stg' | 'prd';

let env: ENV = 'dev'
if (location.host === 'localhost:8080') {
  env = 'dev'
} else if (location.host === 'driver-stg.cc') {
  env = 'stg'
} else {
  env = 'prd'
}

const config = {
  dev: {
    baseApi: 'http://localhost:8081/api',
    uploadApi: 'http://localhost:8081/upload',
    mock: true,
    mockApi: 'http://mock.dev.com',
    cdn: "http://dev.aliyun.com"
  },
  stg: {
    baseApi: 'http://api-stg.company.com/api',
    uploadApi: 'http://api-stg.company.com/upload',
    mock: false,
    mockApi: 'http://mock.stg.com',
    cdn: "http://stg.aliyun.com"
  },
  prd: {
    baseApi: 'http://api.company.com/api',
    uploadApi: 'http://api.company.com/upload',
    mock: false,
    mockApi: '',
    cdn: "http://cdn.aliyun.com"
  },
};

export default {
  env,
  ...config[env], // 动态根据环境引入对应配置
}
```

#### 使用方式
```typescript
// src/utils/request.ts
import config from '@/config';

const instance = axios.create({
  baseURL: config.baseApi,  // 运行时确定
  timeout: 8000,
});

// 在组件中使用
import config from '@/config';

const MyComponent = () => {
  const apiUrl = config.baseApi;
  const isMock = config.mock;

  return <div>当前环境: {config.env}</div>;
};
```

### 优点
1. **部署灵活**：一次构建，多环境部署
2. **运维简单**：可以通过修改域名或添加环境判断逻辑来切换环境
3. **调试方便**：可以在运行时动态修改配置
4. **成本低**：减少构建次数和存储空间

### 缺点
1. **安全性低**：所有配置都暴露在客户端代码中
2. **性能略差**：需要运行时计算环境
3. **维护复杂**：环境判断逻辑可能变得复杂
4. **容错性差**：环境判断错误可能导致使用错误的配置

## 3. 详细对比分析

### 性能对比
| 方面 | 编译时变量 | 运行时变量 |
|------|------------|------------|
| 初始化性能 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 运行时性能 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 包体积 | ⭐⭐⭐⭐ | ⭐⭐⭐ |

### 开发体验对比
| 方面 | 编译时变量 | 运行时变量 |
|------|------------|------------|
| 类型安全 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| IDE 支持 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 调试便利性 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 配置复杂度 | ⭐⭐⭐ | ⭐⭐⭐⭐ |

### 运维对比
| 方面 | 编译时变量 | 运行时变量 |
|------|------------|------------|
| 部署灵活性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| CI/CD 复杂度 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 环境切换便利性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 配置安全性 | ⭐⭐⭐⭐⭐ | ⭐⭐ |

## 4. 使用场景分析

### 编译时变量适用场景
1. **安全要求高**：需要保护 API 密钥、第三方服务配置
2. **性能要求高**：对首屏加载时间有严格要求
3. **团队规范化**：大型团队，需要标准化的工程流程
4. **多环境差异大**：不同环境的配置差异很大

### 运行时变量适用场景
1. **快速迭代**：需要频繁切换环境进行测试
2. **部署成本敏感**：希望减少构建和存储成本
3. **运维便利性**：希望运维人员能够灵活切换环境
4. **配置相对简单**：环境间差异主要是域名和开关

## 5. 实际项目示例

### 编译时变量完整示例

#### 1. 环境文件配置
```bash
# .env.development
NODE_ENV=development
VITE_APP_BASE_URL=http://localhost:8081
VITE_APP_UPLOAD_API=http://localhost:8081/upload
VITE_APP_CDN=http://dev-cdn.company.com
VITE_APP_MOCK=true

# .env.production
NODE_ENV=production
VITE_APP_BASE_URL=https://api.company.com
VITE_APP_UPLOAD_API=https://upload.company.com
VITE_APP_CDN=https://cdn.company.com
VITE_APP_MOCK=false
```

#### 2. TypeScript 类型定义
```typescript
// vite-env.d.ts
interface ImportMetaEnv {
  readonly NODE_ENV: 'development' | 'production' | 'test'
  readonly VITE_APP_BASE_URL: string
  readonly VITE_APP_UPLOAD_API: string
  readonly VITE_APP_CDN: string
  readonly VITE_APP_MOCK: 'true' | 'false'
}
```

#### 3. 使用示例
```typescript
// src/config/env.ts
export const config = {
  baseURL: import.meta.env.VITE_APP_BASE_URL,
  uploadAPI: import.meta.env.VITE_APP_UPLOAD_API,
  cdn: import.meta.env.VITE_APP_CDN,
  mock: import.meta.env.VITE_APP_MOCK === 'true',
  isDev: import.meta.env.DEV,
  isProd: import.meta.env.PROD,
};

// src/utils/request.ts
import { config } from '@/config/env';

const instance = axios.create({
  baseURL: config.baseURL,
  timeout: 8000,
});
```

### 运行时变量完整示例

#### 1. 配置文件
```typescript
// src/config/index.ts
interface Config {
  env: string;
  baseApi: string;
  uploadApi: string;
  cdn: string;
  mock: boolean;
  mockApi: string;
}

class ConfigManager {
  private config: Config;

  constructor() {
    this.config = this.getConfig();
  }

  private getEnvironment(): string {
    const { hostname, port } = location;
    const host = `${hostname}:${port}`;

    // 根据域名判断环境
    if (host === 'localhost:3000' || host === 'localhost:5173') {
      return 'dev';
    } else if (hostname.includes('stg') || hostname.includes('staging')) {
      return 'stg';
    } else {
      return 'prd';
    }
  }

  private getConfig(): Config {
    const env = this.getEnvironment();

    const configs = {
      dev: {
        env: 'development',
        baseApi: 'http://localhost:8081/api',
        uploadApi: 'http://localhost:8081/upload',
        cdn: 'http://dev-cdn.company.com',
        mock: true,
        mockApi: 'http://mock.dev.com',
      },
      stg: {
        env: 'staging',
        baseApi: 'http://api-stg.company.com/api',
        uploadApi: 'http://upload-stg.company.com',
        cdn: 'http://stg-cdn.company.com',
        mock: false,
        mockApi: '',
      },
      prd: {
        env: 'production',
        baseApi: 'https://api.company.com/api',
        uploadApi: 'https://upload.company.com',
        cdn: 'https://cdn.company.com',
        mock: false,
        mockApi: '',
      },
    };

    return configs[env as keyof typeof configs] || configs.dev;
  }

  public getConfig(): Config {
    return this.config;
  }

  public updateConfig(newConfig: Partial<Config>): void {
    this.config = { ...this.config, ...newConfig };
  }
}

export default new ConfigManager().getConfig();
```

#### 2. 使用示例
```typescript
// src/utils/request.ts
import config from '@/config';

const instance = axios.create({
  baseURL: config.baseApi,
  timeout: 8000,
});

// 可以在运行时动态修改配置
if (config.mock) {
  instance.defaults.baseURL = config.mockApi;
}
```

## 6. 混合使用方案

在实际项目中，可以结合两种方式的优点：

```typescript
// src/config/index.ts
interface Config {
  baseApi: string;
  uploadApi: string;
  cdn: string;
  mock: boolean;
}

// 编译时变量作为基础配置
const baseConfig = {
  baseApi: import.meta.env.VITE_APP_BASE_URL,
  uploadApi: import.meta.env.VITE_APP_UPLOAD_API,
  cdn: import.meta.env.VITE_APP_CDN,
  mock: import.meta.env.VITE_APP_MOCK === 'true',
};

// 运行时根据需要覆盖配置
const getRuntimeConfig = (): Config => {
  const config = { ...baseConfig };

  // 特殊情况下的运行时覆盖
  if (location.hostname === 'localhost' && location.port === '3001') {
    config.baseApi = 'http://localhost:3001/api';
    config.mock = true;
  }

  return config;
};

export default getRuntimeConfig();
```

## 7. 最佳实践建议

### 选择原则
1. **小型项目**：优先使用编译时变量，简单直接
2. **大型项目**：根据安全性和部署需求选择
3. **快速原型**：使用运行时变量，便于快速调试
4. **生产项目**：优先考虑编译时变量的安全性

### 实施建议
1. **团队规范**：统一团队的环境变量管理方式
2. **文档完善**：详细记录环境配置和切换方法
3. **自动化测试**：确保不同环境配置的正确性
4. **监控告警**：监控配置错误导致的问题

### 安全考虑
1. **敏感信息**：绝不在前端暴露真正的密钥
2. **配置验证**：运行时验证配置的有效性
3. **错误处理**：优雅处理配置错误的情况

## 8. 流行度和趋势

### 当前流行度
- **编译时变量**：⭐⭐⭐⭐⭐ (主流方案)
- **运行时变量**：⭐⭐⭐ (特定场景使用)

### 技术趋势
1. **编译时变量**正在成为现代前端项目的标准做法
2. **运行时变量**在微前端和多租户系统中仍有重要作用
3. **混合方案**在复杂项目中越来越受欢迎

### 社区支持
- Vite、Webpack、Create React App 等主流工具都优先支持编译时变量
- 大多数开源项目采用编译时变量方案
- 企业级项目中两种方案都有应用

## 总结

两种环境变量管理方式各有优劣，选择时需要根据项目的具体需求：

- **追求安全性和性能**：选择编译时变量
- **追求部署灵活性**：选择运行时变量
- **复杂项目**：考虑混合使用

无论选择哪种方案，都要确保团队统一标准，完善文档，并建立相应的测试和监控机制。
